-- Requires executor support (for loadstring and fast UI updates)
-- loadstring(game:HttpGet("https://soluna-script.vercel.app/main.lua", true))()
local CoreGui = game:GetService("CoreGui")

-- Remove old instance
if CoreGui:FindFirstChild("MiniExecutor") then
	CoreGui.MiniExecutor:Destroy()
end

-- GUI
local gui = Instance.new("ScreenGui")
gui.Name = "MiniExecutor"
gui.ResetOnSpawn = false
gui.Parent = CoreGui

local frame = Instance.new("Frame")
frame.Parent = gui
frame.Size = UDim2.new(0, 520, 0, 340)
frame.Position = UDim2.new(0.5, -260, 0.5, -170)
frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
frame.BackgroundTransparency = 0.4
frame.BorderSizePixel = 0
frame.Active = true
frame.Draggable = true

-- Main Frame Corner
local frameCorner = Instance.new("UICorner")
frameCorner.CornerRadius = UDim.new(0, 12)
frameCorner.Parent = frame

-- Main Frame Border (1px white)
local frameStroke = Instance.new("UIStroke")
frameStroke.Thickness = 1
frameStroke.Color = Color3.fromRGB(255, 255, 255)
frameStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
frameStroke.Parent = frame

-- Title Bar
local title = Instance.new("TextLabel")
title.Parent = frame
title.Size = UDim2.new(1, 0, 0, 34)
title.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
title.Text = "Mini Executor"
title.TextColor3 = Color3.new(1, 1, 1)
title.Font = Enum.Font.GothamBold
title.TextSize = 18
title.BackgroundTransparency = 1

-- Close Button
local closeBtn = Instance.new("TextButton")
closeBtn.Parent = frame
closeBtn.Size = UDim2.new(0, 30, 0, 30)
closeBtn.Position = UDim2.new(1, -36, 0, 6)
closeBtn.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
closeBtn.BorderSizePixel = 0
closeBtn.Text = "X"
closeBtn.TextColor3 = Color3.new(1, 1, 1)
closeBtn.TextScaled = true
closeBtn.Font = Enum.Font.GothamBold

-- Close Button Corner
local closeCorner = Instance.new("UICorner")
closeCorner.CornerRadius = UDim.new(0, 4)
closeCorner.Parent = closeBtn

closeBtn.MouseButton1Click:Connect(function()
	gui:Destroy()
end)

-- Container frame for text area
local container = Instance.new("Frame")
container.Parent = frame
container.Size = UDim2.new(1, -20, 1, -110)
container.Position = UDim2.new(0, 10, 0, 44)
container.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
container.BackgroundTransparency = 0.2
container.BorderSizePixel = 0
container.ClipsDescendants = true

-- Container Corner
local containerCorner = Instance.new("UICorner")
containerCorner.CornerRadius = UDim.new(0, 8)
containerCorner.Parent = container

-- Scrolling Frame for highlighting
local scrollFrame = Instance.new("ScrollingFrame")
scrollFrame.Parent = container
scrollFrame.Size = UDim2.new(1, 0, 1, 0)
scrollFrame.Position = UDim2.new(0, 0, 0, 0)
scrollFrame.BackgroundTransparency = 1
scrollFrame.BorderSizePixel = 0
scrollFrame.ScrollBarThickness = 1
scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
scrollFrame.ScrollingEnabled = false

-- Highlight Layer
local background = Instance.new("TextLabel")
background.Parent = scrollFrame
background.Size = UDim2.new(1, -6, 1, -6)
background.Position = UDim2.new(0, 3, 0, 3)
background.BackgroundTransparency = 1
background.RichText = true
background.TextColor3 = Color3.new(1, 1, 1)
background.Font = Enum.Font.Code
background.TextSize = 16
background.TextXAlignment = Enum.TextXAlignment.Left
background.TextYAlignment = Enum.TextYAlignment.Top
background.TextWrapped = false
background.Text = ""
background.AutomaticSize = Enum.AutomaticSize.XY

-- Scrolling Frame for textbox (actual scrollable input)
local textScrollFrame = Instance.new("ScrollingFrame")
textScrollFrame.Parent = container
textScrollFrame.Size = UDim2.new(1, 0, 1, 0)
textScrollFrame.Position = UDim2.new(0, 0, 0, 0)
textScrollFrame.BackgroundTransparency = 1
textScrollFrame.BorderSizePixel = 0
textScrollFrame.ScrollBarThickness = 1
textScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)

-- Textbox Layer (completely invisible text)
local textbox = Instance.new("TextBox")
textbox.Parent = textScrollFrame
textbox.Size = UDim2.new(1, -6, 1, -6)
textbox.Position = UDim2.new(0, 3, 0, 3)
textbox.BackgroundTransparency = 1
textbox.TextColor3 = Color3.fromRGB(0, 0, 0)
textbox.TextTransparency = 1
textbox.Font = Enum.Font.Code
textbox.TextSize = 16
textbox.MultiLine = true
textbox.ClearTextOnFocus = false
textbox.TextXAlignment = Enum.TextXAlignment.Left
textbox.TextYAlignment = Enum.TextYAlignment.Top
textbox.TextWrapped = false
textbox.Text = ""
textbox.PlaceholderText = "-- write your script here"
textbox.PlaceholderColor3 = Color3.fromRGB(100, 100, 100)
textbox.AutomaticSize = Enum.AutomaticSize.XY

-- Custom caret
local TweenService = game:GetService("TweenService")
local TextService = game:GetService("TextService")

local caret = Instance.new("Frame")
caret.Parent = scrollFrame
caret.Size = UDim2.new(0, 2, 0, 18)
caret.Position = UDim2.new(0, 3, 0, 3)
caret.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
caret.BorderSizePixel = 0
caret.ZIndex = 10
caret.Visible = false

-- Caret blinking animation
local caretVisible = true
local blinkRunning = false

local function startBlinking()
	if blinkRunning then
		return
	end
	blinkRunning = true
	task.spawn(function()
		while caret.Visible and blinkRunning do
			wait(0.5)
			if not blinkRunning then break end
			caretVisible = not caretVisible
			caret.BackgroundTransparency = caretVisible and 0 or 1
		end
	end)
end

local function stopBlinking()
	blinkRunning = false
end

-- Update caret position with tweening
local currentTween = nil
local function updateCaretPosition()
	if not textbox:IsFocused() then
		caret.Visible = false
		stopBlinking()
		return
	end
	caret.Visible = true
	caretVisible = true
	caret.BackgroundTransparency = 0
	
	local cursorPos = textbox.CursorPosition
	local textBeforeCursor = textbox.Text:sub(1, cursorPos - 1)
	
	-- Calculate line and column
	local lines = {}
	for line in (textBeforeCursor .. "\n"):gmatch("([^\n]*)\n") do
		table.insert(lines, line)
	end
	
	local lineNum = #lines
	local lineText = lines[lineNum]
	
	-- Calculate pixel position using TextService for accurate width
	local textSize = TextService:GetTextSize(lineText, 16, Enum.Font.Code, Vector2.new(math.huge, math.huge))
	local xPos = textSize.X + 3
	
	-- Calculate line height using TextService for a single line
	local singleLineSize = TextService:GetTextSize("A", 16, Enum.Font.Code, Vector2.new(math.huge, math.huge))
	local lineHeight = singleLineSize.Y
	local yPos = (lineNum - 1) * lineHeight + 3
	
	-- Update caret height to match line height
	caret.Size = UDim2.new(0, 2, 0, lineHeight)
	
	-- Tween to new position
	if currentTween then
		currentTween:Cancel()
	end
	currentTween = TweenService:Create(caret, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Position = UDim2.new(0, xPos, 0, yPos)
	})
	currentTween:Play()
end

textbox:GetPropertyChangedSignal("CursorPosition"):Connect(updateCaretPosition)
textbox.Focused:Connect(function()
	caret.Visible = true
	caret.BackgroundTransparency = 0
	updateCaretPosition()
	startBlinking()
end)
textbox.FocusLost:Connect(function()
	caret.Visible = false
	stopBlinking()
	if currentTween then
		currentTween:Cancel()
	end
end)

-- Sync scroll positions
textScrollFrame:GetPropertyChangedSignal("CanvasPosition"):Connect(function()
	scrollFrame.CanvasPosition = textScrollFrame.CanvasPosition
end)

-- Update canvas size when text changes
local function updateCanvasSize()
	-- Use AbsoluteSize since textbox has AutomaticSize enabled
	local textSize = textbox.AbsoluteSize
	local canvasSize = UDim2.new(0, math.max(textSize.X + 10, textScrollFrame.AbsoluteSize.X), 0, math.max(textSize.Y + 10, textScrollFrame.AbsoluteSize.Y))
	textScrollFrame.CanvasSize = canvasSize
	scrollFrame.CanvasSize = canvasSize
end

textbox:GetPropertyChangedSignal("TextBounds"):Connect(updateCanvasSize)

-- Execute Button
local executeBtn = Instance.new("TextButton")
executeBtn.Parent = frame
executeBtn.Size = UDim2.new(0.4, 0, 0, 36)
executeBtn.Position = UDim2.new(0.3, 0, 1, -48)
executeBtn.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
executeBtn.BorderSizePixel = 0
executeBtn.Text = "Execute"
executeBtn.TextColor3 = Color3.new(1, 1, 1)
executeBtn.TextScaled = true
executeBtn.Font = Enum.Font.GothamBold

local executeCorner = Instance.new("UICorner")
executeCorner.CornerRadius = UDim.new(0, 8)
executeCorner.Parent = executeBtn

executeBtn.MouseButton1Click:Connect(function()
	local func, compileError = loadstring(textbox.Text)
	if not func then
		warn("Compile Error:", compileError)
		return
	end

	local success, runtimeError = pcall(func)
	if not success then
		warn("Runtime Error:", runtimeError)
	end
end)

----------------------------------------------------------------
-- EXTENSIVE SYNTAX HIGHLIGHTER
----------------------------------------------------------------

-- Keywords (control flow, declarations, operators)
local keywords = {
	["and"]=true, ["break"]=true, ["do"]=true, ["else"]=true,
	["elseif"]=true, ["end"]=true, ["false"]=true, ["for"]=true,
	["function"]=true, ["if"]=true, ["in"]=true, ["local"]=true,
	["nil"]=true, ["not"]=true, ["or"]=true, ["repeat"]=true,
	["return"]=true, ["then"]=true, ["true"]=true, ["until"]=true,
	["while"]=true, ["goto"]=true
}

-- Built-in global functions
local builtins = {
	["print"]=true, ["warn"]=true, ["error"]=true, ["assert"]=true,
	["type"]=true, ["typeof"]=true, ["tonumber"]=true, ["tostring"]=true,
	["pairs"]=true, ["ipairs"]=true, ["next"]=true, ["select"]=true,
	["getmetatable"]=true, ["setmetatable"]=true, ["rawget"]=true, ["rawset"]=true,
	["rawequal"]=true, ["pcall"]=true, ["xpcall"]=true, ["loadstring"]=true,
	["require"]=true, ["spawn"]=true, ["delay"]=true, ["wait"]=true,
	["tick"]=true, ["time"]=true, ["collectgarbage"]=true, ["newproxy"]=true,
	["getfenv"]=true, ["setfenv"]=true, ["unpack"]=true, ["task"]=true
}

-- Built-in libraries and data types
local libraries = {
	["game"]=true, ["workspace"]=true, ["script"]=true, ["shared"]=true,
	["math"]=true, ["string"]=true, ["table"]=true, ["coroutine"]=true,
	["debug"]=true, ["os"]=true, ["io"]=true, ["bit32"]=true, ["utf8"]=true,
	["Instance"]=true, ["Vector2"]=true, ["Vector3"]=true, ["CFrame"]=true,
	["UDim"]=true, ["UDim2"]=true, ["Ray"]=true, ["Axes"]=true, ["Faces"]=true,
	["Color3"]=true, ["BrickColor"]=true, ["Region3"]=true, ["NumberRange"]=true,
	["NumberSequence"]=true, ["ColorSequence"]=true, ["Enum"]=true,
	["Random"]=true, ["TweenInfo"]=true, ["PhysicalProperties"]=true,
	["Rect"]=true, ["Region3int16"]=true, ["Vector2int16"]=true, ["Vector3int16"]=true,
	["NumberSequenceKeypoint"]=true, ["ColorSequenceKeypoint"]=true,
	["PathWaypoint"]=true, ["OverlapParams"]=true, ["RaycastParams"]=true
}

-- Common Roblox services
local services = {
	["Players"]=true, ["Workspace"]=true, ["Lighting"]=true, ["ReplicatedStorage"]=true,
	["ServerScriptService"]=true, ["ServerStorage"]=true, ["StarterGui"]=true,
	["StarterPlayer"]=true, ["StarterPack"]=true, ["Teams"]=true, ["SoundService"]=true,
	["Chat"]=true, ["LocalizationService"]=true, ["TestService"]=true, ["InsertService"]=true,
	["CollectionService"]=true, ["PhysicsService"]=true, ["BadgeService"]=true,
	["MarketplaceService"]=true, ["TeleportService"]=true, ["UserInputService"]=true,
	["ContextActionService"]=true, ["RunService"]=true, ["HttpService"]=true,
	["PathfindingService"]=true, ["TweenService"]=true, ["CoreGui"]=true,
	["DataStoreService"]=true, ["MessagingService"]=true, ["MemoryStoreService"]=true
}

-- Common methods (for :MethodName syntax)
local methods = {
	["Connect"]=true, ["Wait"]=true, ["Fire"]=true, ["Invoke"]=true,
	["Destroy"]=true, ["Clone"]=true, ["FindFirstChild"]=true, ["WaitForChild"]=true,
	["GetChildren"]=true, ["GetDescendants"]=true, ["IsA"]=true, ["FindFirstAncestor"]=true,
	["GetService"]=true, ["GetPropertyChangedSignal"]=true, ["BindToRenderStep"]=true,
	["UnbindFromRenderStep"]=true, ["Disconnect"]=true, ["Play"]=true, ["Stop"]=true,
	["Resume"]=true, ["Pause"]=true, ["Cancel"]=true, ["IsFocused"]=true,
	["ClearAllChildren"]=true, ["GetFullName"]=true, ["SetAttribute"]=true, ["GetAttribute"]=true
}

-- Common properties
local properties = {
	["Parent"]=true, ["Name"]=true, ["ClassName"]=true, ["Position"]=true, ["Size"]=true,
	["CFrame"]=true, ["Transparency"]=true, ["Color"]=true, ["Material"]=true,
	["Anchored"]=true, ["CanCollide"]=true, ["Locked"]=true, ["Visible"]=true,
	["Text"]=true, ["TextColor3"]=true, ["BackgroundColor3"]=true, ["BorderSizePixel"]=true,
	["Character"]=true, ["Humanoid"]=true, ["Health"]=true, ["MaxHealth"]=true,
	["WalkSpeed"]=true, ["JumpPower"]=true, ["UserId"]=true, ["DisplayName"]=true
}

local function highlightLua(text)
	-- First pass: Extract and protect strings/comments with placeholders
	local protected = {}
	local protectedId = 0
	
	local function escapeHtml(str)
		return str:gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
	end
	
	local function createPlaceholder(content, color)
		protectedId = protectedId + 1
		-- Encode the ID as a sequence of control characters
		-- Use chars 3-255 to represent the ID (avoiding 1, 2 which are delimiters)
		-- For IDs 1-253, just use char(id + 2)
		-- This makes the entire placeholder non-alphanumeric
		local placeholder = string.char(1) .. string.char(protectedId + 2) .. string.char(2)
		-- Escape HTML entities in the content, then wrap with font tags
		protected[placeholder] = '<font color="' .. color .. '">' .. escapeHtml(content) .. '</font>'
		return placeholder
	end
	
	-- Process character by character with state flags (text is NOT escaped yet)
	local result = {}
	local i = 1
	local inString = false
	local stringChar = nil
	local inComment = false
	local inMultilineComment = false
	local currentProtected = ""
	
	while i <= #text do
		local char = text:sub(i, i)
		local nextChar = text:sub(i + 1, i + 1)
		
		-- Check for multiline comment start
		if not inString and not inComment and char == "-" and nextChar == "-" then
			local afterDash = text:sub(i + 2, i + 3)
			if afterDash == "[[" then
				inMultilineComment = true
				currentProtected = "--[["
				i = i + 4
			else
				inComment = true
				currentProtected = "--"
				i = i + 2
			end
		-- Check for multiline comment end
		elseif inMultilineComment and char == "]" and nextChar == "]" then
			currentProtected = currentProtected .. "]]"
			table.insert(result, createPlaceholder(currentProtected, "rgb(0,255,120)"))
			currentProtected = ""
			inMultilineComment = false
			i = i + 2
		-- Check for string start
		elseif not inComment and not inMultilineComment and not inString and (char == '"' or char == "'") then
			inString = true
			stringChar = char
			currentProtected = char
			i = i + 1
		-- Check for string end (not escaped)
		elseif inString and char == stringChar then
			local prevChar = text:sub(i - 1, i - 1)
			if prevChar ~= "\\" then
				currentProtected = currentProtected .. char
				table.insert(result, createPlaceholder(currentProtected, "rgb(255,230,0)"))
				currentProtected = ""
				inString = false
				stringChar = nil
				i = i + 1
			else
				currentProtected = currentProtected .. char
				i = i + 1
			end
		-- Check for newline (ends single-line comment and unclosed strings)
		elseif char == "\n" then
			if inComment then
				table.insert(result, createPlaceholder(currentProtected, "rgb(0,255,120)"))
				currentProtected = ""
				inComment = false
				table.insert(result, "\n")
			elseif inString then
				table.insert(result, createPlaceholder(currentProtected, "rgb(255,230,0)"))
				currentProtected = ""
				inString = false
				stringChar = nil
				table.insert(result, "\n")
			else
				table.insert(result, "\n")
			end
			i = i + 1
		-- Inside protected region
		elseif inComment or inMultilineComment or inString then
			currentProtected = currentProtected .. char
			i = i + 1
		-- Regular character - escape special HTML chars
		else
			if char == "&" then
				table.insert(result, "&amp;")
			elseif char == "<" then
				table.insert(result, "&lt;")
			elseif char == ">" then
				table.insert(result, "&gt;")
			else
				table.insert(result, char)
			end
			i = i + 1
		end
	end
	
	-- Close any unclosed protected regions at end of text
	if inComment or inMultilineComment then
		table.insert(result, createPlaceholder(currentProtected, "rgb(0,255,120)"))
	elseif inString then
		table.insert(result, createPlaceholder(currentProtected, "rgb(255,230,0)"))
	end
	
	text = table.concat(result)

	-- Second pass: Apply syntax highlighting to unprotected text only
	
	-- Numbers (bright cyan)
	text = text:gsub("(%f[%d]%d+%.?%d*)",
		"<font color='rgb(0,200,255)'>%1</font>")

	-- Keywords (bold bright magenta)
	for kw in pairs(keywords) do
		text = text:gsub("(%f[%a_])("..kw..")(%f[^%w_])",
			"<b><font color='rgb(255,0,170)'>%2</font></b>")
	end

	-- Built-in functions (bright blue)
	for fn in pairs(builtins) do
		text = text:gsub("(%f[%a_])("..fn..")(%f[^%w_])",
			"<font color='rgb(100,150,255)'>%2</font>")
	end

	-- Libraries and types (bright orange)
	for lib in pairs(libraries) do
		text = text:gsub("(%f[%a_])("..lib..")(%f[^%w_])",
			"<font color='rgb(255,150,50)'>%2</font>")
	end

	-- Services (cyan)
	for svc in pairs(services) do
		text = text:gsub("(%f[%a_])("..svc..")(%f[^%w_])",
			"<font color='rgb(0,220,200)'>%2</font>")
	end
	
	-- Methods (after colon) - light purple
	for method in pairs(methods) do
		text = text:gsub(":("..method..")(%f[^%w_])",
			":<font color='rgb(200,150,255)'>%1</font>%2")
	end
	
	-- Properties (after dot) - light green
	for prop in pairs(properties) do
		text = text:gsub("%.("..prop..")(%f[^%w_])",
			".<font color='rgb(150,255,150)'>%1</font>%2")
	end
	
	-- Highlight 'self' keyword - pink
	text = text:gsub("(%f[%a_])(self)(%f[^%w_])",
		"<font color='rgb(255,180,200)'>%2</font>")

	-- Third pass: Restore protected strings and comments
	-- Control character placeholders are immune to all patterns - direct replacement
	for placeholder, colored in pairs(protected) do
		text = text:gsub(placeholder, colored)
	end

	-- Dim default text slightly
	text = "<font color='rgb(220,220,220)'>" .. text .. "</font>"

	return text
end

textbox:GetPropertyChangedSignal("Text"):Connect(function()
	background.Text = highlightLua(textbox.Text)
	updateCanvasSize()
	updateCaretPosition()
end)